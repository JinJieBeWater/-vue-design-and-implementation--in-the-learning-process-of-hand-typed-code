## 快速 Diff 算法

### 核心

1. 先对相同的前置元素和后置元素进行 patch 操作

2. 通过索引j与newEnd、oldEnd判断
   - j > oldEnd && j <= newEnd 则处理新增节点 
   - j > newEnd && j <= oldEnd 则处理删除节点

3. 处理非理想情况(新旧节点都有遗漏)
   1. 构建新节点key索引表 {key: index}
   2. 遍历旧节点组:
      1. 检查更新数量是否超限
         - 未超限: 继续处理
         - 已超限: 卸载多余节点
      2. 在key索引表中查找:
         - 找到: patch节点并记录位置
         - 未找到: 卸载节点
      3. 判断是否需要移动:
         - 需要: moved = true 
         - 不需要: 更新位置标记
   3. moved = true 新节点中需要有需要移动的节点
      1. 构造最长递增子序列
      2. 从后向前遍历
         > 由于是从后向前遍历, 所以在处理当前节点时后面的节点是已经处理过的位置正确的节点 可用作锚点
         - 如果source[i] === -1 则新增节点
         - 如果i !== seq[s] 则需要移动
         - else 则不需要移动 s指向下一个位置
  
### 图示


```mermaid
flowchart TD
    Start[开始Diff] --> A[处理前置后置相同元素]
    
    A --> B{索引边界判断}
    B -->|j>oldEnd & j<=newEnd| C[新增节点]
    B -->|j>newEnd & j<=oldEnd| D[删除节点]
    B -->|都有遗漏| E[处理非理想情况]
    
    E --> F[构建key索引表]
    F --> G[遍历旧节点组]
    
    G --> H{更新数量检查}
    H -->|未超限| I{key查找}
    H -->|已超限| J[卸载多余节点]
    
    I -->|找到| K[patch节点并记录]
    I -->|未找到| L[卸载节点]
    
    K --> M{需要移动?}
    M -->|是| N[moved为true]
    M -->|否| O[更新位置标记]
    
    N --> P[构造最长递增子序列]
    P --> Q[从后向前遍历未处理新节点]
    
    Q --> R{节点处理}
    R -->|source值为-1| S[新增节点]
    R -->|i不等于seq位置| T[移动节点]
    R -->|其他情况| U[不移动,s前进]
```

